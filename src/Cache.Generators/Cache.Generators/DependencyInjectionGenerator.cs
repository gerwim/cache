using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GerwimFeiken.Cache.Generators;

[Generator]
public class DependencyInjectionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        var addCacheCalls = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (s, _) => SyntaxReceiver.ShouldVisit(s, out var _),
            transform: static (ctx, _) => (InvocationExpressionSyntax)ctx.Node
        );
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider((s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.FoundCacheKey)
            .Select((x, _) => x.ClassDeclarationSyntax);
        
        IncrementalValueProvider<(Compilation Compilation, ImmutableArray<InvocationExpressionSyntax> AddCacheCalls)> source =
            compilationProvider.Combine(addCacheCalls.Collect());
        
        IncrementalValueProvider<(Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarationSyntaxes)> source2 =
            compilationProvider.Combine(provider.Collect());
        

        context.RegisterSourceOutput(source.Combine(source2),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
        
    }

    private static ClassDeclaration GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var properties = classDeclarationSyntax.Members.OfType<PropertyDeclarationSyntax>();

        foreach (var property in properties)
        {
            foreach (AttributeListSyntax attributeListSyntax in property.AttributeLists)
            {
                foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
                {
                    if (context.SemanticModel.GetSymbolInfo(attributeSyntax)
                            .Symbol is not IMethodSymbol attributeSymbol)
                        continue; // if we can't get the symbol, ignore it

                    string attributeName = attributeSymbol.ContainingType.ToDisplayString();
                    
                    // Check the full name of the [CacheKey] attribute.
                    if (attributeName == $"{Constants.Namespace}.{Constants.AttributeName}")
                        return new ClassDeclaration(classDeclarationSyntax, true);
                }
            }
        }

        return new ClassDeclaration(classDeclarationSyntax, false);
    }
    private void GenerateCode(SourceProductionContext context, (Compilation Compilation, ImmutableArray<InvocationExpressionSyntax> AddCacheCalls) cacheCalls, (Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> classDeclarationSyntaxes) classDeclarations)
    {
        var result = new Dictionary<string, string>();
        // Go through all filtered class declarations.
        foreach (var classDeclaration in classDeclarations.classDeclarationSyntaxes)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = classDeclarations.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol)
                continue;

            var className = $"{classDeclaration.Identifier.Text}Cache";
            var interfaceName = $"I{className}";
            
            result.Add(interfaceName, className);
        }
        
        var code = $@"// <auto-generated/>
#nullable enable
namespace Microsoft.Extensions.DependencyInjection;

public static class GerwimFeikenCacheDependencyInjectionExtensions {{
    public static IServiceCollection AddCacheSourceGenerators(this IServiceCollection services)
    {{
        {GenerateServices(result)}
        return services;
    }}
}}
";

        context.AddSource($"GerwimFeiken.Cache.DependencyInjection.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private string GenerateServices(Dictionary<string, string> input)
    {
        var stringBuilder = new StringBuilder();
        foreach (var service in input)
        {
            stringBuilder.AppendLine($"services.AddScoped<global::GerwimFeiken.Cache.{service.Key}, global::GerwimFeiken.Cache.{service.Value}>();");
        }

        return stringBuilder.ToString();
    }

    private sealed record ClassDeclaration(ClassDeclarationSyntax ClassDeclarationSyntax, bool FoundCacheKey)
    {
        public ClassDeclarationSyntax ClassDeclarationSyntax { get; } = ClassDeclarationSyntax;
        public bool FoundCacheKey { get; } = FoundCacheKey;
    }
}